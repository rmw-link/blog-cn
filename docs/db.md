# 接口 

如果时间大于当前时间1分钟，就拒绝接收。

* 获取A的订阅频道列表 
  * 参数
    * 订阅的起始时间 
  * 返回
    * [ 订阅的频道公钥 订阅时间 ] 

* 获取频道标题
  * 参数
    * 频道的公钥
  * 返回
    * 时间戳
    * 频道的标题
    * 频道对标题(标题+时间戳)的签名

* 获取频道的订阅者
  * 参数
    * 编辑距离
  * 返回
    * [公钥 信用分]
      * 积分计算公式 
         * 推送成功一次 积分 = log(e**积分 + (t-1624596444)/7/24/3600))

* 获取频道下一个更新哈希
  * 参数
    * 频道的公钥
    * 当前哈希 （如果为空，表示头开始）
  * 返回
    * 没更新 返回 空
    * 有更新
      * 时间戳
      * 哈希
      * 更新内容的大小
      * 更新内容的标题(不超过64个字节)
      * 频道对标题(时间戳+哈希+更新内容大小+上一个哈希)的签名

* 通过哈希获取内容
  * 参数
    * 哈希
    * offset
    * 位图
  * 返回值
    * 哈希
    * offset

# https://doc.rust-lang.org/std/io/trait.Seek.html
# https://docs.rs/memmap/0.7.0/memmap/struct.MmapMut.html
# https://github.com/oconnor663/bao

频道更新哈希可以获取频道更新的目录

接口 
  获取A的订阅列表，按A同步次数排序
  查找节点公钥


KAD网络设计

有64个桶，每个桶大小为8，当前一个桶被填满的时候，会分裂一下去填充下一个桶。

每个桶再保留32个作为候补，这样就有 32*8*16 = 4096个候补。

每个节点会与自己相近的32*8*16=2048个节点保持通讯
心跳包每19秒一次
UDP 空包的大小 = IP头(20) + UDP头(8) = 28
也就是理论上维持连接的带宽消耗为 2048/19*28 = 3242字节每秒
事实上应该没有这么多，因为不会32个bucket都填满

网络接口
  
FIND 公钥

  返回公钥编辑距离对应的kad桶和候补桶
  如果不足24个，从前后的桶取可用+候补的填充直到填满24个
  返回公钥+IP端口
  



# 数据库设计

表

0. id - 私钥
1. 公钥 - id
2. 登录时间 - 私钥id
3. 私钥id - 登录时间
4. 私钥id - 用户昵称(不超过32个字符)

10. id - 公钥
11. id - 公钥id + 前一个公钥id  // 我订阅的公钥
12. id - 

// 公钥的订阅者
// 100. id - 可用的IPV4 & 端口
// 101. 最后成功连接的时间 - ipv4.id 
// 102. ipv4.id - 最后成功连接时间 
// 103. ipv4.id - 公钥id // 1-1
// 104. 公钥id - ipv4.id // 1-n 

订阅A频道
广度遍历A的订阅者
  A按照Kad存储32*8*16=不超过4096个订阅者
不断迭代填充自己的K桶
检测更新
同步内容

为了防止攻击，每个订阅者订阅需要给A支付
